import '/base64'
import '/random'
import '/string'
import '/asyncio'

import 'xmlio'
import 'xmlio/Node'

NS_CLIENT  = 'jabber:client'
NS_STREAM  = 'http://etherx.jabber.org/streams'
NS_XML     = 'http://www.w3.org/XML/1998/namespace'
NS_TLS     = 'urn:ietf:params:xml:ns:xmpp-tls'
NS_SASL    = 'urn:ietf:params:xml:ns:xmpp-sasl'
NS_BIND    = 'urn:ietf:params:xml:ns:xmpp-bind'
NS_SESSION = 'urn:ietf:params:xml:ns:xmpp-session'
NS_VERSION = 'jabber:iq:version'
NS_PING    = 'jabber:iq:ping'


XMPPError = subclass Exception where


JabberID = subclass object where
  __init__ = @host @user: None @resource: None ~>
    if '@' in @host => @user, _, @host     = @host.partition '@'
    if '/' in @host => @host, _, @resource = @host.partition '/'
    None

  bare = ~> '{}@{}'    .format @user @host
  full = ~> '{}@{}/{}' .format @user @host @resource


Client = subclass xmlio.XMLProtocol where
  __init__ = host loop: None ~>
    @self = JabberID host
    @host = host
    @root = ' '.join $ list'
      'stream:stream xmlns="%s"' % NS_CLIENT
      'xmlns:xml="%s"'           % NS_XML
      'xmlns:stream="%s"'        % NS_STREAM
      'version="1.0" to="%s"'    % host
    @_handles = set!
    (super Client self).__init__ root: @root loop: loop

  #: Start a task bound to this connection.
  #:
  #: async :: coroutine a -> Task
  #:
  async = coro ~>
    task = asyncio.async coro loop: @loop
    task.add_done_callback $ task -> @_handles.remove task
    @_handles.add task
    task

  #: Stop listening for stuff.
  #:
  #: close :: typeof XMLProtocol.close
  #:
  close = self ->
    for handle in @_handles => handle.cancel!
    (super Client self).close!

  #: Generate a random stanza ID.
  #:
  #: randomid :: str
  #:
  randomid = ~> ''.join $ map (_ -> random.choice string.ascii_lowercase) $ range 10

  #: Wait until a response to a request, which is assigned a random ID.
  #:
  #: send_with_id :: (Either Node Element) -> coroutine Element
  #:
  send_with_id = node ~>
    node.set 'id' (id = @randomid)
    yield from $ @send node

    reply = fst $ yield from $ @wait_for xpath: True $
      # Note that the node may be sent to ourselves; we should ignore it.
      '*[@id=%s and @type!="get" and @type!="set"]' % xmlio.quoteattr id

    if reply.get 'type' == 'error' => raise $ XMPPError reply
       otherwise => reply

  #: Respond to an `iq` node.
  #:
  #: respond :: Element (Either Node Element) -> coroutine a
  #:
  respond = req node ~>
    node.set 'id' $ req.get 'id' ''
    node.set 'to' $ req.get 'from'
    yield from $ @send node

  #: XMPP handshake, part 1: `stream:features`.
  #:
  #: load_features :: coroutine a
  #:
  load_features = ~>
    # TODO have a better representation.
    @features, = yield from $ @wait_for $ '{%s}features' % NS_STREAM

  #: XMPP handshake, part 2: TLS.
  #:
  #: starttls :: coroutine a
  #:
  starttls = ~>
    if @features.findall $ '{%s}starttls' % NS_TLS =>
      yield from $ @send $ Node 'starttls' xmlns: NS_TLS
      yield from $ @wait_for $ '{%s}*' % NS_TLS
      waiter = asyncio.Future loop: @loop
      @loop._make_ssl_transport (@transport.get_extra_info 'socket') self None waiter
      yield from waiter
      yield from $ @load_features

  #: XMPP handshake, part 3: authentication. Must be done using one of the protocols
  #: in `features`.
  #:
  #: auth :: str str (Optional str) -> coroutine a
  #:
  auth = user password ~>
    use_auth   = None
    mechanisms = @features.findall $ './/{%s}mechanism' % NS_SASL
    for x in mechanisms => if x.text in @auth.methods => use_auth = @auth.methods !! x.text
    if use_auth  => yield from $ use_auth self user password
       otherwise => raise $ ValueError 'no auth mechanism supported by both sides'
    @self.user = user
    @connection_made @transport
    yield from @load_features

  auth.methods = dict'
    #: Plain authentication: `\0username\0password` in base64.
    #:
    #: _ :: str str -> coroutine a
    #:
    'PLAIN', user password ~>
      yield from $ @send $ Node 'auth' xmlns: NS_SASL mechanism: 'PLAIN' $ bytes.decode
        base64.b64encode $ b'\0' + user.encode 'utf-8' + b'\0' + password.encode 'utf-8'
        'ascii'

      result, = yield from $ @wait_for $ '{%s}*' % NS_SASL
      if result.tag == 'success' =>
         result.tag == 'failure' => raise $ PermissionError user
         otherwise               => raise $ ConnectionError 'incorrect auth result'
    # TODO: DIGEST-MD5, at least.

  #: XMPP handshake, part 4: bind to a resource.
  #:
  #: bind :: str -> coroutine a
  #:
  bind = resource ~>
    @self.resource = resource
    yield from $ @send_with_id $ Node 'iq' type: 'set' $ Node 'bind' xmlns: NS_BIND $ Node 'resource' resource
    yield from $ @send_with_id $ Node 'iq' type: 'set' $ Node 'session' xmlns: NS_SESSION

    @async
      where while True =>
        req, = yield from $ @wait_for $ '{%s}iq[{%s}ping]' % (NS_CLIENT, NS_PING)
        yield from $ @respond req $ Node 'iq' type: 'result'

    @async
      where while True =>
        req, = yield from $ @wait_for $ '{%s}iq[{%s}query]' % (NS_CLIENT, NS_VERSION)
        yield from $ @respond req $ Node 'iq' type: 'result' $ Node 'query' xmlns: NS_VERSION
          Node 'name'    'asyncio.xmpp'
          Node 'version' '0.0.0.0.0.1 pre-alpha'
          Node 'os'      'unknown'


client = user password host port: 5222 loop: None resource: None **: k ->
  loop  = loop or asyncio.get_event_loop!
  proto = snd $ yield from $ loop.create_connection (-> Client host loop) host port **: k
  yield from $ proto.load_features
  yield from $ proto.starttls
  yield from $ proto.auth user password
  yield from $ proto.bind $ resource or proto.randomid
  proto
