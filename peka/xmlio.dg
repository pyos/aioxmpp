import '/asyncio'
import '/xml/etree/ElementTree/tostring'
import '/xml/etree/ElementTree/Element'
import '/xml/etree/ElementTree/XMLPullParser'


XMLWriter = subclass asyncio.StreamWriter where
  #: A XML stanza-based protocol. The stream begins with a root node, `<stream>`,
  #: followed by an arbitrary amount of nodes. The stream may end with `</stream>`
  #: if it was closed gracefully.
  #:
  #: root :: str -- the name of the root tag, e.g. `stream:stream` in XMPP.
  #:
  __init__ = @root: 'stream' *: a **: k ~>
    (super XMLWriter self).__init__ *: a **: k
    @write $ b'<?xml version="1.0" encoding="utf-8"?>'
    @write $ b'<' + @root.encode 'utf-8' + b'>'
    None

  #: Send a single stanza. `yield from` the result of this method to wait until
  #: everything is 100% sent to the other side.
  #:
  #: send :: Element -> coroutine a
  #:
  send = node ~>
    @write $ tostring node 'utf-8'
    @drain!

  #: Gracefully close the connection, optionally closing the socket.
  #:
  #: close :: (Optional bool) -> a
  #:
  close = completely: False ~>
    @write $ b'</' + @root.encode 'utf-8' + b'>'
    if completely => @transport.close!


XMLProtocol = subclass asyncio.streams.FlowControlMixin asyncio.Protocol where
  #: A XML stanza-based protocol. Calls a function for every child of a root node.
  #:
  #: loop :: EventLoop
  #: root :: str
  #:
  __init__ = handle: None root: 'stream' loop: None ~>
    handle => @handle = asyncio.coroutine handle
    @loop  = loop or asyncio.get_event_loop!
    @root  = root
    @level = 0
    @wait  = dict!
    (super XMLProtocol self).__init__!

  connection_made = transport ~>
    @writer = XMLWriter @root transport self None @loop
    @parser = XMLPullParser ('start', 'end')
    (super XMLProtocol self).connection_made transport

  data_received = data ~>
    except err => @parser.feed data
           err :: Exception => @writer.close True
    for (ev, node) in @parser.read_events! => if
      ev == 'start' => @level += 1
      ev == 'end'   =>
        @level -= 1
        @level == 1 => asyncio.async loop: @loop $ @handle node
    (super XMLProtocol self).data_received data

  #: An alias to `writer.send`.
  #:
  #: send :: typeof XMLWriter.send
  #:
  send = node ~> @writer.send node

  #: An alias to `writer.close`.
  #:
  #: close :: typeof XMLWriter.close
  #:
  close = self -> @writer.close True

  #: Handle a single stanza.
  #:
  #: handle :: Element -> coroutine a
  #:
  handle = asyncio.coroutine $ node ~>
    # There is no easy way to use XPath to select this element iff it has a certain name.
    # If we wrap the node in one more element, however, this is trivial: `name`.
    root = Element ''
    root.append node
    for (task, pattern) in @wait.items! =>
      if (result = root.findall pattern) =>
        task.set_result result

  #: Wait for a stanza that matches a certain XPath.
  #:
  #: wait_for :: str -> coroutine [Element]
  #:
  wait_for = match ~>
    task = asyncio.Future loop: @loop
    @wait !! task = match
    except err     => yield from task
           finally => @wait.pop task
