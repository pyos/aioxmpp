import '/asyncio'
import '/logging'
import '/xml/sax/saxutils/quoteattr'

except
  err =>
    import '/lxml/etree/tostring'
    import '/lxml/etree/Element'
    import '/lxml/etree/XMLPullParser'
    _Element = type $ Element 'nil'
  err :: ImportError =>
    import '/xml/etree/ElementTree/tostring'
    import '/xml/etree/ElementTree/Element'
    import '/xml/etree/ElementTree/XMLPullParser'
    _Element = Element


Node = subclass object where
  # ElementTree nodes tend to screw up namespace information.
  # This node doesn't care.
  __init__ = name *: children **: attrs ~>
    @name     = name
    @attrs    = attrs
    @children = list children
    None

  __str__ = self ->
    '<{0}{1}>{2}</{0}>'.format @name
      ''.join $ map ((k, v) -> ' {}={}'.format k $ quoteattr v) @attrs.items!
      ''.join $ map str @children


XMLWriter = subclass asyncio.StreamWriter where
  #: A XML stanza-based protocol. The stream begins with a root node, `<stream>`,
  #: followed by an arbitrary amount of nodes. The stream may end with `</stream>`
  #: if it was closed gracefully.
  #:
  #: root :: str -- the name of the root tag, e.g. `stream:stream` in XMPP.
  #:
  __init__ = @root: 'stream' *: a **: k ~>
    (super XMLWriter self).__init__ *: a **: k
    @write $ b'<?xml version="1.0" encoding="utf-8"?>'
    @write $ b'<' + @root.encode 'utf-8' + b'>'
    None

  #: Send a single stanza. `yield from` the result of this method to wait until
  #: everything is 100% sent to the other side.
  #:
  #: send :: (Either Node Element) -> coroutine a
  #:
  send = node ~>
    data = if
      node :: _Element => tostring node encoding: 'unicode'
      node :: Node     => str node
      otherwise        => raise $ TypeError 'not an Element/Node'
    @_protocol.log.debug 'SEND %s' data
    @write $ data.encode 'utf-8'
    @drain!

  #: Gracefully close the connection, optionally closing the socket.
  #:
  #: close :: (Optional bool) -> a
  #:
  close = completely: False ~>
    @write $ b'</' + (@root.split ' ' !! 0).encode 'utf-8' + b'>'
    if completely => @transport.close!


XMLProtocol = subclass asyncio.streams.FlowControlMixin asyncio.Protocol where
  #: A XML stanza-based protocol. Calls a function for every child of a root node.
  #:
  #: loop :: EventLoop
  #: root :: str
  #:
  __init__ = handle: None root: 'stream' loop: None ~>
    handle => @handle = asyncio.coroutine handle
    @loop  = loop or asyncio.get_event_loop!
    @root  = root
    @wait  = dict!
    @log   = logging.getLogger 'asyncio.xml'
    (super XMLProtocol self).__init__!

  connection_made = transport ~>
    @level     = 0
    @transport = transport
    @writer    = XMLWriter @root transport self None @loop
    @parser    = XMLPullParser ('start', 'end')
    (super XMLProtocol self).connection_made transport

  data_received = data ~>
    # Some servers tend to act like it's the start of the document
    # in case of errors. ElementTree can't parse that.
    if data.startswith b'<?' => data = data.partition b'?>' !! 2

    except err => @parser.feed data
           err :: Exception => @writer.close True

    for (ev, node) in @parser.read_events! => if
      ev == 'start' => @level += 1
      ev == 'end'   =>
        @level -= 1
        @level == 1 => asyncio.async loop: @loop $ @handle node
    (super XMLProtocol self).data_received data

  connection_lost = exc ~>
    for task in @wait => task.cancel!
    (super XMLProtocol self).connection_lost exc

  #: An alias to `writer.send`.
  #:
  #: send :: typeof XMLWriter.send
  #:
  send = node ~> @writer.send node

  #: An alias to `writer.close`.
  #:
  #: close :: typeof XMLWriter.close
  #:
  close = self -> @writer.close True

  #: Handle a single stanza.
  #:
  #: handle :: Element -> coroutine a
  #:
  handle = asyncio.coroutine $ node ~>
    @log.debug 'RECV %s' $ tostring node encoding: 'unicode'
    # There is no easy way to use XPath to select this element iff it has a certain name.
    # If we wrap the node in one more element, however, this is trivial: `name`.
    root = Element 'root'
    root.append node
    for (task, pattern) in @wait.items! =>
      if (result = root.findall pattern) =>
        task.set_result result

  #: Wait for a stanza that matches a certain XPath.
  #:
  #: wait_for :: str -> coroutine [Element]
  #:
  wait_for = match ~>
    task = asyncio.Future loop: @loop
    @wait !! task = match
    except err     => yield from task
           finally => @wait.pop task
