import '/base64'
import '/random'
import '/string'
import '/asyncio'
import '/datetime/datetime'

import 'xmlio'
import 'xmlio/Node'

NS_CLIENT  = 'jabber:client'
NS_STREAM  = 'http://etherx.jabber.org/streams'
NS_XML     = 'http://www.w3.org/XML/1998/namespace'
NS_TLS     = 'urn:ietf:params:xml:ns:xmpp-tls'
NS_SASL    = 'urn:ietf:params:xml:ns:xmpp-sasl'
NS_BIND    = 'urn:ietf:params:xml:ns:xmpp-bind'
NS_SESSION = 'urn:ietf:params:xml:ns:xmpp-session'
NS_STANZAS = 'urn:ietf:params:xml:ns:xmpp-stanzas'
NS_DELAY   = 'urn:xmpp:delay'


_maybe_text_of = node -> if
  node      => (node !! 0).text
  otherwise => None


XMPPError = subclass Exception where
  #: An `iq`/`presence`/`message` with a type of `error`.
  #:
  #: node  :: Maybe ElementBase -- the node that contains the error.
  #: error :: Maybe ElementBase -- the `{jabber:client}error` element itself.
  #:
  __init__ = node: None ~>
    @node  = node
    @error = not $ node is None => node.findall ('./{%s}error' % NS_CLIENT)
    @error = head $ @error or list' None
    (super XMPPError self).__init__ node

  __str__ = self -> if
    @error is None => 'unknown-error'
    otherwise      => (@error !! 0).tag.rsplit '}' 1 !! -1


XMPPElement = subclass object where
  __getattr__ = name ~> getattr @_node name
  __init__    = node ~>
    @_time = datetime.utcnow!
    @_node = node
    None

  #: Convert this stanza to a different type.
  #:
  #: as :: type -> ElementBase
  #:
  as = t ~> self where @__class__ = t

  #: The sender of this stanza.
  #:
  #: from :: JabberID
  #:
  from = ~> JabberID $ @get 'from'

  #: The unique ID assigned to this request/response.
  #:
  #: id :: Maybe str
  #:
  id = ~> @get 'id'

  #: The type of this stanza: get, set, result, error.
  #:
  #: type :: Maybe str
  #:
  type = ~> @get 'type'

  #: When this stanza was sent (not received.)
  #:
  #: time :: datetime
  #:
  time = ~>
    delay = @findall $ './{%s}delay' % NS_DELAY
    if delay     => datetime.strptime ((delay !! 0).get 'stamp') '%Y-%m-%dT%H:%M:%SZ'
       otherwise => @_time

  ismessage  = ~> @tag == '{%s}message'  % NS_CLIENT
  ispresence = ~> @tag == '{%s}presence' % NS_CLIENT
  isiq       = ~> @tag == '{%s}iq'       % NS_CLIENT


XMPPMessage = subclass XMPPElement where
  body    = ~> _maybe_text_of $ @findall $ './{%s}body'    % NS_CLIENT
  subject = ~> _maybe_text_of $ @findall $ './{%s}subject' % NS_CLIENT


XMPPPresence = subclass XMPPElement where
  #: The type of this presence: error, (un)available, dnd, busy, something else.
  #:
  #: type :: str
  #:
  type = ~> @get 'type' 'available'

  #: A user-specified status string.
  #:
  #: status :: Maybe str
  #:
  status = ~> _maybe_text_of $ @findall $ './{%s}status' % NS_CLIENT


JabberID = subclass object where
  __init__ = @host @user: None @resource: None ~>
    if '@' in @host => @user, _, @host     = @host.partition '@'
    if '/' in @host => @host, _, @resource = @host.partition '/'
    None

  bare = ~> if
    @user     => '{}@{}'.format @user @host
    otherwise => @host

  full = ~> if
    @resource => '{}@{}/{}'.format @user @host @resource
    otherwise => @bare

  __str__ = self -> @full


Client = subclass xmlio.XMLProtocol where
  __init__ = host loop: None ~>
    @ext  = (subclass object)!
    @self = JabberID host
    @host = host
    @root = ' '.join $ list'
      'stream:stream xmlns="%s"' % NS_CLIENT
      'xmlns:xml="%s"'           % NS_XML
      'xmlns:stream="%s"'        % NS_STREAM
      'version="1.0" to="%s"'    % host
    (super Client self).__init__ root: @root loop: loop

    @connect 'node'     priority: 999 @_slot_node
    @connect 'iq'       priority: 999 @_slot_iq_request
    @connect 'message'  priority: 999 @_slot_message
    @connect 'presence' priority: 999 @_slot_presence
    # These messages mean the same thing.
    @connect 'message-chat'   priority: 999 @_slot_message_chat
    @connect 'message-normal' priority: 999 @_slot_message_chat
    None

  #: Load an extension from a given module.
  #:
  #: extend :: ModuleType -> a
  #:
  extend = module ~> not $ hasattr @ext module.name => setattr @ext module.name $ module.init self

  #: Handle an arbitrary stanza.
  #:
  #: _slot_node :: Element -> coroutine bool
  #:
  _slot_node = asyncio.coroutine $ node ~>
    node = XMPPElement node
    if node.ismessage  => yield from $ @emit 'message'  $ node.as XMPPMessage
       node.ispresence => yield from $ @emit 'presence' $ node.as XMPPPresence
       node.isiq       => if
         node.type == 'result' => yield from $ @emit 'response' node
         node.type == 'error'  => yield from $ @emit 'response' node
         otherwise             => yield from $ @emit 'iq'       node
       node.tag == '{%s}features' % NS_STREAM => yield from $ @emit 'ready' (@features = node)

  #: Handle an `iq` request (by replying with an error.)
  #:
  #: _slot_iq_request :: Element -> coroutine bool
  #:
  _slot_iq_request = asyncio.coroutine $ node ~>
    yield from $ @respond node $ Node 'iq' type: 'error' $
      Node 'error' type: 'cancel' $ Node 'service-unavailable' xmlns: NS_STANZAS
    True

  #: Dispatch a message.
  #:
  #: _slot_message :: Element -> coroutine bool
  #:
  _slot_message = node ~>
    yield from $ @emit ('message-%s' % node.type) node

  #: Dispatch a one-on-one chat message.
  #:
  #: _slot_message_chat :: Element -> coroutine bool
  #:
  _slot_message_chat = node ~>
    jid   = node.from
    stop  = jid.bare == jid.full
    stop |= yield from (@emit ('message-chat-%s' % jid.bare) node)
    stop or yield from (@emit ('message-chat-%s' % jid.full) node)

  #: Dispatch a presence.
  #:
  #: _slot_presence :: Element -> coroutine a
  #:
  _slot_presence = node ~>
    # TODO emit some authorization-related signals.
    jid   = node.from
    stop  = jid.bare == jid.full
    stop |= yield from (@emit ('presence-%s' % jid.bare) node)
    stop or yield from (@emit ('presence-%s' % jid.full) node)

  #: Generate a random stanza ID.
  #:
  #: randomid :: str
  #:
  randomid = ~> ''.join $ map (_ -> random.choice string.ascii_lowercase) $ range 10

  #: Wait until a response to a request, which is assigned a random ID.
  #:
  #: request :: (Either Node Element) -> coroutine Element
  #:
  request = node ~>
    node.set 'id' (id = @randomid)
    yield from $ @send node

    while True =>
      reply = yield from $ @wait_for 'response'
      reply.id == id => break!

    reply.type == 'error' => raise $ XMPPError reply
    reply

  #: Respond to an `iq` node.
  #:
  #: respond :: Element (Either Node Element) -> coroutine a
  #:
  respond = req node ~>
    node.set 'id' $ req.id or ''
    node.set 'to' $ str req.from
    yield from $ @send node

  #: XMPP handshake, part 1: TLS.
  #:
  #: starttls :: coroutine a
  #:
  starttls = ~>
    if @features.findall $ './{%s}starttls' % NS_TLS =>
      yield from $ @send $ Node 'starttls' xmlns: NS_TLS

      while True =>
        result = yield from $ @wait_for 'node'
        result.tag == '{%s}proceed' % NS_TLS => break!
        result.tag == '{%s}failure' % NS_TLS => raise $ ConnectionError 'TLS request denied'

      waiter = asyncio.Future loop: @loop
      @loop._make_ssl_transport (@transport.get_extra_info 'socket') self None waiter
      yield from waiter
      yield from $ @wait_for 'ready'

  #: XMPP handshake, part 2: authentication. Must be done using one of the protocols
  #: in `features`.
  #:
  #: auth :: str str -> coroutine a
  #:
  auth = user password ~>
    use_auth   = None
    mechanisms = @features.findall $ './/{%s}mechanism' % NS_SASL
    for x in mechanisms => if x.text in @auth.methods => use_auth = @auth.methods !! x.text
    if use_auth  => yield from $ use_auth self user password
       otherwise => raise $ ValueError 'no auth mechanism supported by both sides'
    @self.user = user
    @connection_made @transport
    yield from $ @wait_for 'ready'

  auth.methods = dict'
    #: Plain authentication: `\0username\0password` in base64.
    #:
    #: _ :: str str -> coroutine a
    #:
    'PLAIN', user password ~>
      yield from $ @send $ Node 'auth' xmlns: NS_SASL mechanism: 'PLAIN' $ bytes.decode
        base64.b64encode $ b'\0' + user.encode 'utf-8' + b'\0' + password.encode 'utf-8'
        'ascii'

      while True =>
        result = yield from $ @wait_for 'node'
        result.tag == '{%s}success' % NS_SASL => break!
        result.tag == '{%s}failure' % NS_SASL => raise $ PermissionError user
    # TODO: DIGEST-MD5, at least.

  #: XMPP handshake, part 3: bind to a resource.
  #:
  #: bind :: str -> coroutine a
  #:
  bind = resource ~>
    @self.resource = resource
    yield from $ @request $ Node 'iq' type: 'set' $ Node 'bind' xmlns: NS_BIND $ Node 'resource' resource
    yield from $ @request $ Node 'iq' type: 'set' $ Node 'session' xmlns: NS_SESSION


client = user password host port: 5222 loop: None resource: None **: k ->
  loop  = loop or asyncio.get_event_loop!
  proto = snd $ yield from $ loop.create_connection (-> Client host loop) host port **: k
  yield from $ proto.wait_for 'ready'
  yield from $ proto.starttls
  yield from $ proto.auth user password
  yield from $ proto.bind $ resource or proto.randomid
  proto
