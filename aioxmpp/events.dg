import '/asyncio'
import '/collections'


EventSystem = subclass object where
  __init__ = loop: None ~>
    @loop  = loop or asyncio.get_event_loop!
    @slots = collections.defaultdict list
    @tasks = set!
    (super EventSystem self).__init__!

  __del__   = self       -> @close!
  __enter__ = self       -> self
  __exit__  = self _ _ _ ->
    @close!
    False

  #: Start a task bound to this system.
  #:
  #: async :: (coroutine a) -> Task
  #:
  async = coro ~>
    task = asyncio.async coro loop: @loop
    task.add_done_callback $ task -> except
      err => @tasks.remove task
      err :: KeyError =>
    @tasks.add task
    task

  #: Cancel a task bound to this system after some time.
  #:
  #: timelimit :: float (coroutine a) -> coroutine a
  #:
  timelimit = timeout coro ~>
    task   = @async coro
    handle = @loop.call_later timeout task.cancel
    except _       => yield from task
           finally => handle.cancel!

  #: Stop all tasks bound to this system.
  #:
  #: close :: -> a
  #:
  close = self ->
    for task in @tasks => task.cancel!
    for name in @slots => for obj in @slots !! name => obj :: asyncio.Future => @disconnect name obj
    @tasks.clear!

  #: Add an event handler.
  #:
  #: connect :: str (a -> b) (Optional int) -> c
  #:
  connect = name callback priority: 0 ~>
    nope = for (index, (p, _)) in enumerate (@slots !! name) => p >= priority => break!
    nope => index = len (@slots !! name)
    (@slots !! name).insert index (priority, callback)

  #: Remove a previously added event handler.
  #:
  #: disconnect :: str (a -> b) -> c
  #:
  disconnect = name callback ~>
    callback :: asyncio.Future => callback.cancel!
    index = 0
    nope = for (index, (_, cb)) in enumerate (@slots !! name) => cb == callback => break!
    nope or (@slots !! name).pop index

  #: Call handlers for an event in order, stop at the first one that returns True.
  #: Returns True iff one of the handlers returned True.
  #:
  #: emit :: str (Optional a) -> coroutine bool
  #:
  emit = name arg: None ~>
    not $ for (_, slot) in @slots !! name =>
      if slot :: asyncio.Future => slot.set_result arg
         yield from $ slot arg => break!

  #: Wait until an event is fired.
  #:
  #: wait_for :: str (Optional int) -> coroutine a
  #:
  wait_for = name priority: 0 ~>
    waiter = asyncio.Future loop: @loop
    @connect name waiter priority
    except _       => yield from waiter
           finally => @disconnect name waiter
