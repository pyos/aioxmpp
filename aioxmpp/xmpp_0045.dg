import '/asyncio'
import '/collections'

import 'xmlio/Node'
import 'xmpp'
import 'xmpp/JabberID'
import 'xmpp/XMPPError'
import 'xmpp/NS_CLIENT'
import 'xmpp/NS_DELAY'


name      = 'muc'
namespace = 'http://jabber.org/protocol/muc'


init = subclass object where
  #: XEP-0045: Multi-User Chat
  #:
  #: http://xmpp.org/extensions/xep-0045.html
  #:
  __init__ = @proto ~>
    # @proto.extend $ import 'xmpp_0030'
    # ...
    @proto.connect 'message-groupchat' priority: 999 @_slot_message
    @entered = set!
    None

  #: Dispatch a MUC message.
  #:
  #: _slot_message :: Element -> coroutine bool
  #:
  _slot_message = node ~>
    yield from $ @proto.emit ('message-groupchat-%s' % node.from.bare) node

  #: Enter a groupchat.
  #:
  #: () :: (Either JabberID str) (Optional str) (Optional int) -> coroutine Room
  #:
  __call__ = room nick password: None history: None ~>
    room = if
      room :: JabberID => JabberID room.bare None nick
      otherwise        => JabberID room      None nick
    room.bare in @entered => raise $ ValueError $ 'room {} already entered'.format room.bare
    @entered.add room.bare

    node = Node 'x' xmlns: namespace
    not $ password is None => node.children.append $ Node 'password' password
    not $ history  is None => node.children.append $ Node 'history' maxstanzas: (str history)
    yield from $ @proto.send $ Node 'presence' id: @proto.randomid to: room.full node

    # If successful, the server does not send a response. Instead,
    # we need to listen for a non-`error` presence from this room.
    except
      err =>
        resp = yield from $ @proto.wait_for $ 'presence-%s' % room.bare
        resp.type == 'error' => raise $ XMPPError resp
      finally => err =>
        @entered.remove room.bare
        # XXX should we send an `unavailable` presence if `err` is not an `XMPPError`?

    room = Room self room @proto
    room.enqueue $ resp.as MUCPresence
    room


Room = subclass object where
  #: A single multi-user chat.
  #:
  #: jid   :: JabberID
  #: proto :: Client
  #:
  __init__ = @ext @jid @proto ~>
    @queue  = collections.deque ()
    @waiter = None
    @left   = False
    @proto.connect ('presence-%s'          % @jid.bare) @onpresence
    @proto.connect ('message-groupchat-%s' % @jid.bare) @onmessage
    None

  onpresence = asyncio.coroutine $ x ~> @enqueue $ x.as MUCPresence
  onmessage  = asyncio.coroutine $ x ~> @enqueue $ x.as MUCMessage

  #: Put the node onto the event queue and wake up those who wait for it.
  #:
  #: enqueue :: Element -> bool
  #:
  enqueue = node ~>
    @queue.append node
    @waiter => @waiter.set_result True
    @waiter = None
    if node :: MUCPresence and node.from.full == @jid.full and node.type == 'unavailable' =>
      @left = True
      @proto.disconnect ('presence-%s'          % @jid.bare) @onpresence
      @proto.disconnect ('message-groupchat-%s' % @jid.bare) @onmessage
      @ext.entered.remove @jid.bare
    True

  #: Fetch the next item from the queue. If there is none, wait until one is received.
  #:
  #: __iter__ :: -> coroutine MUCNode
  #:
  __iter__ = self ->
    while not @queue => yield from $
      @left   => raise GeneratorExit
      @waiter = @waiter or asyncio.Future loop: @proto.loop
    @queue.popleft!

  #: Exit this MUC.
  #:
  #: exit :: (Optional str) -> coroutine a
  #:
  exit = reason: None ~>
    node = Node 'presence' to: @jid.full type: 'unavailable'
    reason => node.children.append $ Node 'status' reason
    yield from $ @proto.send node


MUCElement = subclass xmpp.XMPPElement where
  room = ~> @from.bare
  nick = ~> @from.resource


MUCMessage  = subclass MUCElement xmpp.XMPPMessage  where
MUCPresence = subclass MUCElement xmpp.XMPPPresence where
  status      = ~> raise NotImplementedError
  affiliation = ~> raise NotImplementedError  # NOTE these may not appear
  role        = ~> raise NotImplementedError  #   in every `presence`.
