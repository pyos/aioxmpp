import '/asyncio'
import '/collections'

import 'xmlio/Node'
import 'xmpp'
import 'xmpp/JabberID'
import 'xmpp/XMPPError'


NS      = 'http://jabber.org/protocol/muc'
NS_USER = 'http://jabber.org/protocol/muc#user'


name = 'muc'
init = subclass object where
  #: XEP-0045: Multi-User Chat
  #:
  #: http://xmpp.org/extensions/xep-0045.html
  #:
  __init__ = @proto ~>
    # @proto.extend $ import 'xmpp_0030'
    # ...
    @proto.connect 'message-groupchat' priority: 999 @_slot_message
    @entered = set!
    None

  #: Dispatch a MUC message.
  #:
  #: _slot_message :: XMPPElement -> coroutine bool
  #:
  _slot_message = node ~>
    yield from $ @proto.emit ('message-groupchat-%s' % node.from.bare) node

  #: Enter a groupchat.
  #:
  #: () :: (Either JabberID str) (Optional str) (Optional int) -> coroutine Room
  #:
  __call__ = room nick password: None history: None ~>
    room = if
      room :: JabberID => JabberID room.bare None nick
      otherwise        => JabberID room      None nick
    room.bare in @entered => raise $ ValueError $ 'room {} already entered'.format room.bare
    @entered.add room.bare

    node = Node 'x' xmlns: NS
    not $ password is None => node.children.append $ Node 'password' password
    not $ history  is None => node.children.append $ Node 'history' maxstanzas: (str history)
    yield from $ @proto.send $ Node 'presence' id: @proto.randomid to: room.full node

    task = Room self room @proto
    # If successful, the server does not send a response. Instead,
    # we need to listen for a non-`error` node from this room.
    task.enqueue $ yield from task
    task


Room = subclass object where
  #: A single multi-user chat.
  #:
  #: jid    :: JabberID
  #: proto  :: Client
  #: roster :: dict str (str, str, str, str, JabberID)
  #:        -- maps nicknames to `(type, status, affiliation, role, real_jid)` tuples.
  #:
  __init__ = @ext @jid @proto ~>
    @queue  = collections.deque ()
    @waiter = None
    @left   = False
    @roster = dict' (@jid.resource, (None, None, None, None, @proto.self))
    @proto.connect ('presence-%s'          % @jid.bare) @onpresence
    @proto.connect ('message-chat-%s'      % @jid.bare) @onmessage
    @proto.connect ('message-groupchat-%s' % @jid.bare) @onmessage
    None

  onpresence = asyncio.coroutine $ x ~> @enqueue $ x.as MUCPresence
  onmessage  = asyncio.coroutine $ x ~> @enqueue $ x.as MUCMessage

  #: Whether waiting on this room is of any use.
  #:
  #: ok :: bool
  #:
  ok = ~> bool @queue or not @left

  #: Put the node onto the event queue and wake up those who wait for it.
  #:
  #: enqueue :: Element -> bool
  #:
  enqueue = node ~>
    node.self = node.nick == @jid.resource
    node :: MUCPresence =>
      if node.type == 'unavailable' => @roster.pop node.nick
         otherwise =>
           _, _, a, b, c = @roster.get node.nick (None, None, None, None, None)
           @roster !! node.nick = node.type, node.status, node.affiliation or a, node.role or b,
             if node.real_jid => JabberID node.real_jid
                otherwise     => c

      node.self and node.type in ('unavailable', 'error') =>
        @left = True
        @proto.disconnect ('presence-%s'          % @jid.bare) @onpresence
        @proto.disconnect ('message-chat-%s'      % @jid.bare) @onmessage
        @proto.disconnect ('message-groupchat-%s' % @jid.bare) @onmessage
        @ext.entered.remove @jid.bare

    @queue.append node
    @waiter => @waiter.set_result True
    @waiter = None
    False

  #: Fetch the next item from the queue. If there is none, wait until one is received.
  #:
  #: __iter__ :: -> coroutine MUCNode
  #:
  __iter__ = self ->
    while not @queue => yield from $ @waiter or (@waiter = asyncio.Future loop: @proto.loop)
    resp = @queue.popleft!
    resp :: MUCPresence and resp.type == 'error' => raise $ XMPPError resp
    resp

  #: Exit this MUC.
  #:
  #: exit :: (Optional str) -> coroutine a
  #:
  exit = reason: None ~>
    node = Node 'presence' to: @jid.full type: 'unavailable'
    reason => node.children.append $ Node 'status' reason
    yield from $ @proto.send node


MUCElement = subclass xmpp.XMPPElement where
  room = ~> @from.bare
  nick = ~> @from.resource


MUCMessage = subclass MUCElement xmpp.XMPPMessage where
  private = ~> @type != 'groupchat'


MUCPresence = subclass MUCElement xmpp.XMPPPresence where
  mucdata     = ~> head $ @findall $ './{%s}x/{%s}item' % (NS_USER, NS_USER)
  affiliation = ~> @mucdata.get 'affiliation'
  role        = ~> @mucdata.get 'role'
  real_jid    = ~> @mucdata.get 'jid'
