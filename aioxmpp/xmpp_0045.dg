import '/asyncio'
import '/collections'
import '/datetime/datetime'

import 'xmlio/Node'
import 'xmpp/JabberID'
import 'xmpp/XMPPError'
import 'xmpp/NS_CLIENT'
import 'xmpp/NS_DELAY'


name      = 'muc'
namespace = 'http://jabber.org/protocol/muc'


init = subclass object where
  #: XEP-0045: Multi-User Chat
  #:
  #: http://xmpp.org/extensions/xep-0045.html
  #:
  __init__ = @proto ~>
    # @proto.extend $ import 'xmpp_0030'
    # ...
    @proto.connect 'message-groupchat' priority: 999 @_slot_message
    @entered = set!
    None

  #: Dispatch a MUC message.
  #:
  #: _slot_message :: Element -> coroutine bool
  #:
  _slot_message = node ~>
    yield from $ @proto.emit ('message-groupchat-%s' % (JabberID $ node.get 'from').bare) node

  #: Enter a groupchat.
  #:
  #: () :: (Either JabberID str) (Optional str) (Optional int) -> coroutine Room
  #:
  __call__ = room nick password: None history: None ~>
    room = if
      room :: JabberID => JabberID room.bare None nick
      otherwise        => JabberID room      None nick
    room.bare in @entered => raise $ ValueError $ 'room {} already entered'.format room.bare

    node = Node 'x' xmlns: namespace
    not $ password is None => node.children.append $ Node 'password' password
    not $ history  is None => node.children.append $ Node 'history' maxstanzas: (str history)
    yield from $ @proto.send $ Node 'presence' id: @proto.randomid to: room.full node

    # If successful, the server does not send a response. Instead,
    # we need to listen for a non-`error` presence from this room.
    resp = yield from $ @proto.wait_for $ 'presence-%s' % room.bare
    resp.get 'type' == 'error' => raise $ XMPPError $ resp.findall ('{%s}error' % NS_CLIENT) !! 0
    room = Room self room @proto
    yield from $ room._enqueue resp
    room


Room = subclass object where
  #: A single multi-user chat.
  #:
  #: jid   :: JabberID
  #: proto :: Client
  #:
  __init__ = @ext @jid @proto ~>
    @queue  = collections.deque ()
    @waiter = None
    @left   = False
    @proto.connect ('presence-%s'          % @jid.bare) @_enqueue
    @proto.connect ('message-groupchat-%s' % @jid.bare) @_enqueue
    @ext.entered.add @jid.bare
    None

  #: Put the node onto the event queue and wake up those who wait for it.
  #:
  #: _enqueue :: Element -> coroutine bool
  #:
  _enqueue = asyncio.coroutine $ node ~>
    @queue.append (node, datetime.utcnow!)
    @waiter => @waiter.set_result True
    @waiter = None
    if node.get 'from' == @jid.full and node.get 'type' == 'unavailable' =>
      @left = True
      @proto.disconnect ('presence-%s'          % @jid.bare) @_enqueue
      @proto.disconnect ('message-groupchat-%s' % @jid.bare) @_enqueue
      @ext.entered.remove @jid.bare
    True

  #: Fetch the next item from the queue. If there is none, wait until one is received.
  #:
  #: __iter__ :: -> coroutine MUCNode
  #:
  __iter__ = self ->
    while not @queue => yield from $
      @left   => raise GeneratorExit
      @waiter = @waiter or asyncio.Future loop: @proto.loop
    node, ts = @queue.popleft!
    if node.tag == '{%s}message'  % NS_CLIENT => MUCMessage  node ts
       node.tag == '{%s}presence' % NS_CLIENT => MUCPresence node ts

  #: Exit this MUC.
  #:
  #: exit :: (Optional str) -> coroutine a
  #:
  exit = reason: None ~>
    node = Node 'presence' to: @jid.full type: 'unavailable'
    reason => node.children.append $ Node 'status' reason
    yield from $ @proto.send node


maybe_text = node -> if
  node      => (node !! 0).text
  otherwise => None


MUCNode = subclass object where
  __init__ = @node @_time ~>
  jid  = ~> JabberID $ @node.get 'from'
  room = ~> @jid.bare
  nick = ~> @jid.resource
  time = ~>
    delay = @node.findall $ '{%s}delay' % NS_DELAY
    if delay     => datetime.strptime ((delay !! 0).get 'stamp') '%Y-%m-%dT%H:%M:%SZ'
       otherwise => @_time


MUCMessage = subclass MUCNode where
  body    = ~> maybe_text $ @node.findall $ '{%s}body'    % NS_CLIENT
  subject = ~> maybe_text $ @node.findall $ '{%s}subject' % NS_CLIENT


MUCPresence = subclass MUCNode where
  type        = ~> @node.get 'type' 'available'
  status      = ~> raise NotImplementedError
  affiliation = ~> raise NotImplementedError  # NOTE these may not appear
  role        = ~> raise NotImplementedError  #   in every `presence`.