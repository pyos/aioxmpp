import '/asyncio'
import '/logging'
import '/collections'
import '/xml/parsers/expat'
import '/xml/sax/saxutils/escape'
import '/xml/sax/saxutils/quoteattr'

import 'events/EventSystem'

etree = except
  err => import '/lxml/etree' pure
  err :: ImportError => import '/xml/etree/ElementTree' pure


#: A thin wrapper around `etree.Element` that simplifies creation of nodes.
#:
#: Node :: str *(Either Element str) **str -> Element
#:
Node = name *: children **: attrs ->
  e = etree.Element name attrs
  x = None
  for c in children => if
    c :: str => if
      x is None => e.text = (e.text or '') + c
      otherwise => x.tail = (x.tail or '') + c
    otherwise => e.append (x = c)
  e


XMLProtocol = subclass EventSystem asyncio.streams.FlowControlMixin asyncio.Protocol where
  #: A XML stanza-based protocol. Emits a `node` event for every child of a root node.
  #:
  #: log  :: Logger
  #: loop :: EventLoop
  #: root :: str
  #:
  __init__ = root: 'stream' loop: None ~>
    @loop  = loop or asyncio.get_event_loop!
    @root  = root
    @log   = logging.getLogger 'asyncio.xml'
    (super XMLProtocol self).__init__ loop: loop

  connection_made = transport ~>
    @_level = 0
    @_elems = collections.deque!
    @parser = expat.ParserCreate None '}'
    @parser.StartElementHandler  = @_onstart
    @parser.CharacterDataHandler = @_oncdata
    @parser.EndElementHandler    = @_onend
    @writer = asyncio.StreamWriter transport self None @loop
    @writer.write $ b'<?xml version="1.0" encoding="utf-8"?>'
    @writer.write $ b'<' + @root.encode 'utf-8' + b'>'
    (super XMLProtocol self).connection_made transport

  data_received = data ~>
    except err => @parser.Parse data
           err :: Exception =>
             @log.error 'XML parsing error' exc_info: True
             @close!
    (super XMLProtocol self).data_received data

  _onstart = name attrs ~>
    @_level += 1
    @_level > 1 => @_elems.append $ etree.Element (@_fix1 name) $ dict $ map @_fix2 attrs.items!

  _fix1 = n ~> if
    '}' in n  => '{' + n
    otherwise => n

  _fix2 = (k, v) ~> if
    '}' in k  => '{' + k, v
    otherwise => k, v

  _onend = name ~>
    node = @_elems.pop!
    @_level -= 1
    if @_level == 0 => close!
       @_level >  1 => (@_elems !! -1).append node
       @_level == 1 =>
         @log.debug 'RECV %s' $ etree.tostring node encoding: 'unicode'
         @async $ @emit 'node' node

  _oncdata = data ~>
    e = @_elems !! -1
    x = if (len e => e !! -1) (otherwise => None)
    if x is None => e.text = (e.text or '') + data
       otherwise => x.tail = (x.tail or '') + data

  connection_lost = exc ~>
    (super XMLProtocol self).close!  # The transport has already been closed.
    (super XMLProtocol self).connection_lost exc

  #: Send a single stanza. `yield from` the result of this method to wait until
  #: everything is 100% sent to the other side.
  #:
  #: send :: Element -> coroutine a
  #:
  send = node ~>
    data = etree.tostring node
    @log.debug 'SEND %s' $ data.decode 'utf-8' 'surrogateescape'
    @writer.write data
    @writer.drain!

  #: Gracefully close the connection.
  #:
  #: close :: -> a
  #:
  close = self ->
    except err => @writer.write $ b'</' + (@root.split ' ' !! 0).encode 'utf-8' + b'>'
           err :: IOError => # already closed or something
    @writer.close!
